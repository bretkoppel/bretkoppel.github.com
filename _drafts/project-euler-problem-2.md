---
layout: post
title: "Project Euler Problem 2"
description: "Tackling Project Euler's Problem 2 in C# and Clojure"
category: articles
tags: [project euler, clojure, c#]
#image:
  #feature: so-simple-sample-image-2.jpg
  #credit: Michael Rose
  #creditlink: http://mademistakes.com
comments: false  
---

Lately I've been exploring [Project Euler](http://projecteuler.net/ "Project Euler") as a way to get started with Clojure. This post will feature solutions to [Project Euler Problem 2](http://projecteuler.net/problem=2) in C# and Clojure, so if you're trying to avoid spoilers the now's your change [look at puppies instead](https://encrypted.google.com/search?tbm=isch&q=puppies&tbs=imgo:1). Problem 2 is defined as:

> Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:
>
> 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
>
> By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.

I like to start out with the simplest approach I can find. A simple loop should do the trick:

{% highlight csharp %}
public static void Problem2_Loop()
{
  var n = new List<int> { 0, 1 };
  var sum = 0;
  int nextFib;
  do
  {
      nextFib = n[n.Count - 2] + n[n.Count - 1];
      n.Add(nextFib);

      if (nextFib % 2 == 0)
          sum += nextFib;
  } while (nextFib < 4000000);

  Console.WriteLine(sum);
}
{% endhighlight %}

I actually thought this method would end up being the quickest, but decided I wanted to give recursion a shot anyway:

{% highlight csharp %}
public static void Problem2_Recursive()
{
  Console.WriteLine(EvenFibonacciToLimit(4000000).Sum());
}

private static IEnumerable<int> EvenFibonacciToLimit(int limit)
{
    var tester = new Func<int, bool>((item) => item % 2 == 0);
    return FibonacciToLimit(limit, null, tester);
}

private static IEnumerable<int> FibonacciToLimit(int limit, List<int> sequence = null, Func<int, bool> tester = null, List<int> filteredSequence = null)
{
    if (sequence == null)
        sequence = new List<int> { 0, 1 };

    var nextFib = sequence[sequence.Count - 1] + sequence[sequence.Count - 2];
    if (nextFib >= limit)
        return tester == null ? sequence : filteredSequence;

    sequence.Add(nextFib);
    if (tester != null && tester(nextFib))
    {
        if (filteredSequence == null)
            filteredSequence = new List<int>();

        filteredSequence.Add(nextFib);
    }

    return FibonacciToLimit(limit, sequence, tester, filteredSequence);
}
{% endhighlight %}

How does the recursive solution compare to the looped? They both run in ~1ms per 1000 calls in my testing. Now, on to the Clojure solution. As always, you can plug this into the online [REPL][1] to verify it:

{% highlight clojure %}
(defn fib-even [limit]
  (loop [x 0 y 1 acc 0]
   (let [term (+ x y)]
    (if (< y limit)
     (recur y term (if (even? term) (+ acc term) acc))
     acc))))

(println (fib-even 4000000))
{% endhighlight %}

This averages 1.2Î¼s per call and seems pretty clean to me. Note that the benchmarks aren't comparable between languages as they're running on totally different machine configurations. Do you have a better solution? Let me know on [Twitter](https://twitter.com/bretkoppel)!

[1]:	http://tryclj.com/											"Try Clojure"